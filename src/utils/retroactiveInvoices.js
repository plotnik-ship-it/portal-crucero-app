import { collection, getDocs, query, where } from 'firebase/firestore';
import { db } from '../services/firebase';
import { generateInvoice } from '../services/invoiceService';

/**
 * Generate invoices for all existing payments that don't have invoices yet
 * This is a one-time utility to retroactively create invoices for payments
 * that were applied before the invoice system was implemented
 */
export const generateRetroactiveInvoices = async (agencyId) => {
    try {
        console.log('üîÑ Starting retroactive invoice generation...');

        // Get all families (without where clause to avoid index requirement)
        const familiesRef = collection(db, 'families');
        const familiesSnapshot = await getDocs(familiesRef);

        // Filter by agencyId in memory
        const agencyFamilies = familiesSnapshot.docs.filter(doc => {
            const data = doc.data();
            return data.agencyId === agencyId;
        });

        console.log(`üìã Found ${agencyFamilies.length} families for agency ${agencyId}`);

        let totalInvoicesGenerated = 0;
        let totalPaymentsProcessed = 0;
        const errors = [];

        // Process each family
        for (const familyDoc of agencyFamilies) {
            const bookingId = familyDoc.id;
            const familyData = familyDoc.data();

            console.log(`\nüë• Processing family: ${familyData.displayName} (${familyData.bookingCode})`);

            try {
                // Get all payments for this family
                const paymentsRef = collection(db, 'families', bookingId, 'payments');
                const paymentsSnapshot = await getDocs(paymentsRef);

                if (paymentsSnapshot.empty) {
                    console.log('   ‚ö†Ô∏è No payments found');
                    continue;
                }

                console.log(`   üí∞ Found ${paymentsSnapshot.size} payments`);

                // Get existing invoices for this family to avoid duplicates
                const invoicesRef = collection(db, 'invoices');
                const invoicesSnapshot = await getDocs(query(invoicesRef, where('bookingId', '==', bookingId)));

                // Create a set of payment IDs that already have invoices
                const paymentIdsWithInvoices = new Set();
                invoicesSnapshot.docs.forEach(invoiceDoc => {
                    const invoiceData = invoiceDoc.data();
                    if (invoiceData.payments) {
                        invoiceData.payments.forEach(payment => {
                            paymentIdsWithInvoices.add(payment.paymentId);
                        });
                    }
                });

                console.log(`   üìÑ ${paymentIdsWithInvoices.size} payments already have invoices`);

                // Process each payment
                for (const paymentDoc of paymentsSnapshot.docs) {
                    const paymentId = paymentDoc.id;

                    // Skip if this payment already has an invoice
                    if (paymentIdsWithInvoices.has(paymentId)) {
                        console.log(`   ‚è≠Ô∏è Skipping payment ${paymentId} (already has invoice)`);
                        continue;
                    }

                    try {
                        // Generate invoice for this payment
                        console.log(`   ‚ú® Generating invoice for payment ${paymentId}...`);
                        await generateInvoice(bookingId, [paymentId], { autoGenerated: false });
                        totalInvoicesGenerated++;
                        totalPaymentsProcessed++;
                        console.log(`   ‚úÖ Invoice generated successfully`);
                    } catch (paymentError) {
                        console.error(`   ‚ùå Error generating invoice for payment ${paymentId}:`, paymentError);
                        errors.push({
                            bookingId,
                            bookingCode: familyData.bookingCode,
                            paymentId,
                            error: paymentError.message
                        });
                    }
                }
            } catch (familyError) {
                console.error(`‚ùå Error processing family ${bookingId}:`, familyError);
                errors.push({
                    bookingId,
                    bookingCode: familyData.bookingCode,
                    error: familyError.message
                });
            }
        }

        // Summary
        console.log('\n' + '='.repeat(60));
        console.log('üìä RETROACTIVE INVOICE GENERATION SUMMARY');
        console.log('='.repeat(60));
        console.log(`‚úÖ Total invoices generated: ${totalInvoicesGenerated}`);
        console.log(`üí∞ Total payments processed: ${totalPaymentsProcessed}`);
        console.log(`üë• Total families processed: ${familiesSnapshot.size}`);

        if (errors.length > 0) {
            console.log(`\n‚ö†Ô∏è Errors encountered: ${errors.length}`);
            errors.forEach((err, index) => {
                console.log(`\n${index + 1}. Family: ${err.bookingCode || err.bookingId}`);
                console.log(`   Payment: ${err.paymentId || 'N/A'}`);
                console.log(`   Error: ${err.error}`);
            });
        }

        console.log('\n' + '='.repeat(60));

        return {
            success: true,
            totalInvoicesGenerated,
            totalPaymentsProcessed,
            totalFamilies: familiesSnapshot.size,
            errors
        };
    } catch (error) {
        console.error('‚ùå Fatal error in retroactive invoice generation:', error);
        throw error;
    }
};

/**
 * Generate invoices for a specific family's payments
 * @param {string} bookingId - Family ID
 * @returns {Promise<Object>} - Summary of generation
 */
export const generateInvoicesForFamily = async (bookingId) => {
    try {
        console.log(`üîÑ Generating invoices for family ${bookingId}...`);

        // Get all payments for this family
        const paymentsRef = collection(db, 'families', bookingId, 'payments');
        const paymentsSnapshot = await getDocs(paymentsRef);

        if (paymentsSnapshot.empty) {
            return {
                success: true,
                message: 'No payments found for this family',
                invoicesGenerated: 0
            };
        }

        // Get existing invoices to avoid duplicates
        const invoicesRef = collection(db, 'invoices');
        const invoicesQuery = query(invoicesRef, where('bookingId', '==', bookingId));
        const invoicesSnapshot = await getDocs(invoicesQuery);

        const paymentIdsWithInvoices = new Set();
        invoicesSnapshot.docs.forEach(invoiceDoc => {
            const invoiceData = invoiceDoc.data();
            if (invoiceData.payments) {
                invoiceData.payments.forEach(payment => {
                    paymentIdsWithInvoices.add(payment.paymentId);
                });
            }
        });

        let invoicesGenerated = 0;
        const errors = [];

        // Generate invoice for each payment without one
        for (const paymentDoc of paymentsSnapshot.docs) {
            const paymentId = paymentDoc.id;

            if (paymentIdsWithInvoices.has(paymentId)) {
                continue;
            }

            try {
                await generateInvoice(bookingId, [paymentId], { autoGenerated: false });
                invoicesGenerated++;
            } catch (error) {
                errors.push({ paymentId, error: error.message });
            }
        }

        return {
            success: true,
            invoicesGenerated,
            totalPayments: paymentsSnapshot.size,
            errors
        };
    } catch (error) {
        console.error('Error generating invoices for family:', error);
        throw error;
    }
};
