import {
    collection,
    doc,
    getDoc,
    getDocs,
    addDoc,
    updateDoc,
    deleteDoc,
    query,
    where,
    orderBy,
    serverTimestamp,
    runTransaction
} from 'firebase/firestore';
import { db, auth } from './firebase';

/**
 * Generate a unique invoice number
 * Format: INV-YYYY-NNNN (e.g., INV-2026-0001)
 */
const generateInvoiceNumber = async () => {
    const year = new Date().getFullYear();
    const prefix = `INV-${year}-`;

    // Get all invoices for current year to find the next number
    const invoicesRef = collection(db, 'invoices');
    const q = query(
        invoicesRef,
        where('invoiceNumber', '>=', prefix),
        where('invoiceNumber', '<', `INV-${year + 1}-`),
        orderBy('invoiceNumber', 'desc')
    );

    const snapshot = await getDocs(q);

    if (snapshot.empty) {
        return `${prefix}0001`;
    }

    // Extract the number from the last invoice
    const lastInvoice = snapshot.docs[0].data();
    const lastNumber = parseInt(lastInvoice.invoiceNumber.split('-')[2]);
    const nextNumber = (lastNumber + 1).toString().padStart(4, '0');

    return `${prefix}${nextNumber}`;
};

/**
 * Generate an invoice for one or more payments
 * @param {string} bookingId - Family ID
 * @param {Array<string>} paymentIds - Array of payment IDs to include
 * @param {Object} options - Additional options
 * @returns {Promise<Object>} - Created invoice data with ID
 */
export const generateInvoice = async (bookingId, paymentIds, options = {}) => {
    try {
        // Get family data
        const familyDoc = await getDoc(doc(db, 'families', bookingId));
        if (!familyDoc.exists()) {
            throw new Error('Family not found');
        }
        const familyData = { id: familyDoc.id, ...familyDoc.data() };

        // Get group data for cruise info
        let groupData = null;
        if (familyData.groupId) {
            const groupDoc = await getDoc(doc(db, 'groups', familyData.groupId));
            if (groupDoc.exists()) {
                groupData = groupDoc.data();
            }
        }

        // Get payment details
        const payments = [];
        let total = 0;

        for (const paymentId of paymentIds) {
            const paymentDoc = await getDoc(doc(db, 'families', bookingId, 'payments', paymentId));
            if (paymentDoc.exists()) {
                const paymentData = { id: paymentDoc.id, ...paymentDoc.data() };
                payments.push({
                    paymentId: paymentData.id,
                    date: paymentData.appliedAt || paymentData.date,
                    amount: paymentData.amountCad,
                    currency: 'CAD',
                    method: paymentData.method || 'Payment',
                    reference: paymentData.reference || '',
                    cabinNumber: paymentData.targetCabinNumber || familyData.cabinNumbers?.[0] || 'N/A'
                });
                total += paymentData.amountCad;
            }
        }

        if (payments.length === 0) {
            throw new Error('No valid payments found');
        }

        // Generate invoice number
        const invoiceNumber = await generateInvoiceNumber();

        // Create invoice document
        const invoiceData = {
            invoiceNumber,
            bookingId,
            groupId: familyData.groupId || null,
            agencyId: options.agencyId || familyData.agencyId || null,

            // Passenger information
            passengerInfo: {
                name: familyData.displayName,
                email: familyData.email,
                bookingCode: familyData.bookingCode,
                cabinNumbers: familyData.cabinNumbers || []
            },

            // Cruise information
            cruiseInfo: groupData ? {
                shipName: groupData.shipName || 'N/A',
                sailDate: groupData.sailDate || null,
                itinerary: groupData.itinerary ?
                    groupData.itinerary.map(day => day.port).join(' - ') :
                    'N/A'
            } : null,

            // Payments included
            payments,

            // Totals
            subtotal: total,
            taxes: 0.00,
            total,
            currency: 'CAD',

            // Metadata
            status: 'issued',
            issuedAt: serverTimestamp(),
            sentAt: null,
            createdBy: auth.currentUser?.email || 'system',
            createdAt: serverTimestamp(),
            updatedAt: serverTimestamp(),

            // PDF URL (to be set after PDF generation)
            pdfUrl: null,

            // Auto-generated flag
            autoGenerated: options.autoGenerated || false
        };

        const invoicesRef = collection(db, 'invoices');
        const docRef = await addDoc(invoicesRef, invoiceData);

        console.log(`✅ Invoice ${invoiceNumber} created successfully`);

        return { id: docRef.id, ...invoiceData };
    } catch (error) {
        console.error('Error generating invoice:', error);
        throw error;
    }
};

/**
 * Get all invoices for a family
 * @param {string} bookingId - Family ID
 * @returns {Promise<Array>} - Array of invoices
 */
export const getInvoicesByFamily = async (bookingId) => {
    try {
        const invoicesRef = collection(db, 'invoices');

        // Query without orderBy to avoid requiring a composite index
        const q = query(
            invoicesRef,
            where('bookingId', '==', bookingId)
        );

        const snapshot = await getDocs(q);
        const invoices = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data(),
            issuedAt: doc.data().issuedAt?.toDate() || null,
            sentAt: doc.data().sentAt?.toDate() || null,
            createdAt: doc.data().createdAt?.toDate() || null
        }));

        // Sort in memory by createdAt descending
        invoices.sort((a, b) => {
            const aTime = a.createdAt?.getTime() || 0;
            const bTime = b.createdAt?.getTime() || 0;
            return bTime - aTime;
        });

        return invoices;
    } catch (error) {
        console.error('Error getting invoices by family:', error);
        throw error;
    }
};

/**
 * Get invoice by ID
 * @param {string} invoiceId - Invoice ID
 * @returns {Promise<Object|null>} - Invoice data or null
 */
export const getInvoiceById = async (invoiceId) => {
    try {
        const invoiceDoc = await getDoc(doc(db, 'invoices', invoiceId));
        if (invoiceDoc.exists()) {
            const data = invoiceDoc.data();
            return {
                id: invoiceDoc.id,
                ...data,
                issuedAt: data.issuedAt?.toDate() || null,
                sentAt: data.sentAt?.toDate() || null,
                createdAt: data.createdAt?.toDate() || null
            };
        }
        return null;
    } catch (error) {
        console.error('Error getting invoice by ID:', error);
        throw error;
    }
};

/**
 * Update invoice status
 * @param {string} invoiceId - Invoice ID
 * @param {string} status - New status (draft, issued, sent, cancelled)
 * @returns {Promise<void>}
 */
export const updateInvoiceStatus = async (invoiceId, status) => {
    try {
        const invoiceRef = doc(db, 'invoices', invoiceId);
        const updates = {
            status,
            updatedAt: serverTimestamp()
        };

        if (status === 'sent') {
            updates.sentAt = serverTimestamp();
        }

        await updateDoc(invoiceRef, updates);
        console.log(`✅ Invoice ${invoiceId} status updated to ${status}`);
    } catch (error) {
        console.error('Error updating invoice status:', error);
        throw error;
    }
};

/**
 * Update invoice PDF URL
 * @param {string} invoiceId - Invoice ID
 * @param {string} pdfUrl - PDF download URL
 * @returns {Promise<void>}
 */
export const updateInvoicePdfUrl = async (invoiceId, pdfUrl) => {
    try {
        const invoiceRef = doc(db, 'invoices', invoiceId);
        await updateDoc(invoiceRef, {
            pdfUrl,
            updatedAt: serverTimestamp()
        });
        console.log(`✅ Invoice ${invoiceId} PDF URL updated`);
    } catch (error) {
        console.error('Error updating invoice PDF URL:', error);
        throw error;
    }
};

/**
 * Delete an invoice
 * @param {string} invoiceId - Invoice ID
 * @param {boolean} force - If true, allows deleting any invoice (admin only). If false, only drafts can be deleted.
 * @returns {Promise<void>}
 */
export const deleteInvoice = async (invoiceId, force = false) => {
    try {
        const invoiceDoc = await getDoc(doc(db, 'invoices', invoiceId));
        if (!invoiceDoc.exists()) {
            throw new Error('Invoice not found');
        }

        if (!force) {
            const invoiceData = invoiceDoc.data();
            if (invoiceData.status !== 'draft') {
                throw new Error('Only draft invoices can be deleted');
            }
        }

        await deleteDoc(doc(db, 'invoices', invoiceId));
        console.log(`✅ Invoice ${invoiceId} deleted successfully`);
    } catch (error) {
        console.error('Error deleting invoice:', error);
        throw error;
    }
};

/**
 * Get all invoices for an agency (admin only)
 * @param {string} agencyId - Agency ID
 * @returns {Promise<Array>} - Array of invoices
 */
export const getInvoicesByAgency = async (agencyId) => {
    try {
        const invoicesRef = collection(db, 'invoices');

        // Query without orderBy to avoid requiring a composite index
        const q = query(
            invoicesRef,
            where('agencyId', '==', agencyId)
        );

        const snapshot = await getDocs(q);
        const invoices = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data(),
            issuedAt: doc.data().issuedAt?.toDate() || null,
            sentAt: doc.data().sentAt?.toDate() || null,
            createdAt: doc.data().createdAt?.toDate() || null
        }));

        // Sort in memory by createdAt descending
        invoices.sort((a, b) => {
            const aTime = a.createdAt?.getTime() || 0;
            const bTime = b.createdAt?.getTime() || 0;
            return bTime - aTime;
        });

        return invoices;
    } catch (error) {
        console.error('Error getting invoices by agency:', error);
        throw error;
    }
};

